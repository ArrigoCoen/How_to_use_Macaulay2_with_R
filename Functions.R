#-------------------------------------------------------------------------#
#                                                                         #
#                 FUNCTIONS TO CONTROL MACAULAY2 SOFTWARE                 #
#                                                                         #
#-------------------------------------------------------------------------#

# V1 FECHA

#-------------------------------------------------------------------------#
# OBSERVACIONES:

# 1. Bla bla bla
# 2. Bla bla bla
# 3. Bla bla bla
#



# LIBRARIES ---------------------------------------------------------------

library(stringr) # to use function "str_trim"


# soatnuh -----------------------------------------------------------------



#-------------------------------------------------------------------------#




#' Generator of a Macaulay2 file
#'
#'
#'
#' @param text_to_run vector with the commands of the Macaulay2 software that will be write in the file
#' @param add_date bolean that controls if the date of generation of the file should be printed on the .m2 file
#' @param folder_M2_files folder where the file will be store
#' @param M2_file_name name of the Macaulay2 file (the name of the .m2 file)
#'
#' @return
#' @export
#'
#' @examples
#' 
#' initial_comments <- c("This is a .m2 file generated by the function gen_m2_file","Author: Arrigo Coen") # beginning comments
#' text_to_run <- c("R = QQ[x,y,z]","I = ideal(x-2*y+3*z-7,2*x+y+z-4,-3*x+2*y-2*z+10)","primaryDecomposition I") # the equation to run
#' M2_file_name <- "Macaulay2_file" # the folder were the .m2 files will be stored
#' output_folder_m2_files <- "Macaulay2_output" # the folder were the output files of the .m2 files will be save
#' folder_M2_files<- "Macaulay2_files" # name of the .m2 file that we generate
#' output_file_name = "Solving_equation_with_Macaulay2_OUT" # name of output txt file
#' add_date = F
#' add_date = T
gen_m2_file <- function(text_to_run,M2_file_name,folder_M2_files, add_date=T) {
  # Correcting initial comments
  if(add_date) initial_comments <- c(initial_comments, paste("Generated on",format(Sys.time(), "%b %d %Y, at %X")))
  initial_comments <- paste0(c("-- ",paste0(initial_comments,collapse = "\n-- ")),collapse = "")
  # Correcting text
  text_to_run <- paste0(text_to_run,"\n")
  # Adding comments and text to run
  text_to_run <- paste0(c(initial_comments,"\n\n",text_to_run,"\n"))
  # File path
  file_name <- paste0(c(folder_M2_files,"/",M2_file_name,".m2"),collapse = "")
  # Writing the .m2 file
  write.table(text_to_run, file=file_name, append = F, sep = "", dec = ".",row.names = F, col.names = F, quote = FALSE)
  cat("The file ",file_name," was generated\n")
}


#' Generate text of the M2 file
#'
#' @param vec_variables 
#' @param vec_equations 
#'
#' @return
#' @export
#'
#' @examples
#' 
#' initial_comments <- c("This is a .m2 file generated by the function gen_m2_file","Author: Arrigo Coen") # beginning comments
#' M2_file_name <- "Macaulay2_file" # the folder were the .m2 files will be stored
#' output_folder_m2_files <- "Macaulay2_output" # the folder were the output files of the .m2 files will be save
#' folder_M2_files<- "Macaulay2_files" # name of the .m2 file that we generate
#' output_file_name = "Solving_equation_with_Macaulay2_OUT" # name of output txt file
#' add_date = F
#' add_date = T
#' vec_equations = c("x-2*y+3*z-7","2*x+y+z-4","-3*x+2*y-2*z+10")
#' vec_variables = c("x","y","z")
#' gen_eq_solver_text_for_m2_files(vec_variables, vec_equations) 
#' 
gen_eq_solver_text_for_m2_files <- function(vec_variables, vec_equations) {
  
  text_R = paste0("R = QQ[",paste0(vec_variables,collapse = ","),"]")
  text_I = paste0("I = ideal(",paste0(vec_equations,collapse = ", "),")")
  text_primaryI = "primaryDecomposition I"
  
  text_to_run = c(text_R, text_I,text_primaryI)
  return(text_to_run)
}


#' Given the output of read.table and a phrase_to_look_at this function returns the 
#' indext where the phrase was found
#'
#' @param data_txt output of a read.table function
#' @param phrase_to_look_at string that will be look for at the begging of each line
#'
#' @return
#' @export
#'
#' @examples
#' txt_file <- 'Macaulay2_output/Macaulay2_file_long_output_out.txt'
#' txt_file <- '/Users/arrigocoen/Dropbox/GitHub/2020 Arrigo Repos/How_to_use_Macaulay2_with_R/Macaulay2_output/Macaulay2_file_long_output_out.txt'
#' data_txt = read.table(txt_file, fill = F, header = FALSE , sep = "\t")
#' phrase_to_look_at <- "o3 = {ideal ("
#' idx_phrase <- find_index_of_phrase(data_txt,phrase_to_look_at)
#' data_txt[idx_phrase,]
find_index_of_phrase <- function(data_txt,phrase_to_look_at) {
  unlist_mydata <- unlist(data_txt)
  length_phrase <- nchar(phrase_to_look_at)
  (idx_phrase <- which(substr(unlist_mydata,1,length_phrase)==phrase_to_look_at))
  return(idx_phrase)
}


#' The vector of text for a particular output
#' 
#' Given the vector of text of a txt file, and an output numeber, this function
#' returns the entries of the vector that contain the information of it.
#'
#' @param idx_output 
#' @param data_txt 
#'
#' @return
#' @export
#'
#' @examples
#' txt_file <- '/Users/arrigocoen/Dropbox/GitHub/2020 Arrigo Repos/How_to_use_Macaulay2_with_R/Macaulay2_output/Macaulay2_file_long_output_out.txt'
#' data_txt = read.table(txt_file, fill = F, header = FALSE , sep = "\t")
#' idx_output <- 3
#' raw_text_output_vector_text_M2(idx_output,data_txt)
raw_text_output_vector_text_M2 <- function(idx_output,data_txt) {
  # In the Macaulay2 output is common for the expression to have the form
  # "o3 = " and "o3 : ", for example in the case of idx_output=3. 
  # The first represents the output and the second
  # the type of variable is the output. Then we need to find the index 
  # of the all the entries of the vector data_txt (in fact is a matrix)
  # that contain the information of this output.
  phrase_to_look_at <- paste0(c("o",idx_output," = "),collapse = "")
  idx_ini_vec_text <- find_index_of_phrase(data_txt,phrase_to_look_at) -1
  # In the case of the first row, we could be making the mistake of taking 
  # the previous output. To solve this, we review this line to see if it is
  # only numbers. If it is only numbers it is the powers of the next line,
  # if not then we should not use it for the equation.
  possible_first_row <- data_txt[idx_ini_vec_text,]
  (possible_first_row_no_spaces <- gsub("\\s+", "", str_trim(possible_first_row)))
  if(!suppressWarnings(!is.na(as.numeric(possible_first_row_no_spaces)))) idx_ini_vec_text <- idx_ini_vec_text+1
  # The last line is selected as the line with a starting phrase as "o3 : ",
  # in the case of "idx_output=3"
  phrase_to_look_at <- paste0(c("o",idx_output," : "),collapse = "")
  idx_fin_vec_text <- find_index_of_phrase(data_txt,phrase_to_look_at) -1
  # text_equation is a vector with the text of the output of the idx_output 
  text_equation <- data_txt[idx_ini_vec_text:idx_fin_vec_text,]
  return(text_equation)
}


#' Correction of text of an equation
#' 
#' Given a vector with the text of an ouput of a Macaulay2 file, this function:
#'     1) add the exponents to the proper places
#'     2) eliminates the lines of the type "----------"
#'
#' @param text_equation 
#'
#' @return
#' @export
#'
#' @examples
#' txt_file <- 'Macaulay2_output/Macaulay2_file_long_output_out.txt'
#' txt_file <- '/Users/arrigocoen/Dropbox/GitHub/2020 Arrigo Repos/How_to_use_Macaulay2_with_R/Macaulay2_output/Macaulay2_file_long_output_out.txt'
#' txt_file <- 'Macaulay2_output/K4_allN1222_out.txt' # Example with a line of the type: "-----------"
#' 
#' data_txt = read.table(txt_file, fill = F, header = FALSE , sep = "\t")
#' idx_output <- 3
#' text_equation <- raw_text_output_vector_text_M2(idx_output,data_txt)
#' 
#' add_powers_and_errase_extra_lines(text_equation) 
add_powers_and_errase_extra_lines <- function(text_equation) {
  
  print_info <- F # only for pourpuses of debuging
  vec_ii_for <- max(length(text_equation)-1,1):1
  # text_equation contians the lines with the text between "o3 = ideal" and "o3 : Ideal of R" of the .txt file 
  # (in the case that 'idx_output=3')
  text_equation
  # The next for loops over all the rows that make the invariants
  for(ii in vec_ii_for) {
    (current_row <- text_equation[ii])
    (current_row_no_spaces <- gsub("\\s+", "", str_trim(current_row)))
    if(print_info) cat("ii=",ii,"\n",current_row,"\n")
    if(substr(current_row,1,20) == "     ---------------"){
      text_equation <- text_equation[-ii]
      if(print_info) cat("was eliminated because the spaces\n")
      next
    }
    if(current_row_no_spaces == ""){
      text_equation <- text_equation[-ii]
      if(print_info) cat("was eliminated because the its empty\n")
      next
    }
    # In case that the row has no letters, is a power of the next row
    # and we extract its numbers
    if(suppressWarnings(!is.na(as.numeric(current_row_no_spaces)))) {
      exponents_found <- T
      bellow_current_row <- text_equation[ii+1]
      (posible_exponents <- current_row)
      (idx_exponents <- unlist(gregexpr("[[:digit:]]+", current_row)))
      vec_exponents <- regmatches(posible_exponents, gregexpr("[[:digit:]]+", posible_exponents)) # sin "+" se regresa un vector con cada dÃ­gito
      (vec_exponents <- as.numeric(unlist(vec_exponents)))
      # This for paste in the proper places the powers and add the strings "^{" and "}" arround it
      for(jj in length(idx_exponents):1) {
        (one_exponent_index <- idx_exponents[jj])
        bellow_current_row <- paste0(substr(bellow_current_row,1,one_exponent_index-1),"^{",vec_exponents[jj],"}",substr(bellow_current_row,one_exponent_index,nchar(bellow_current_row)))
      }
      text_equation[ii+1] <- bellow_current_row
      text_equation <- text_equation[-ii]
      if(print_info) cat(" pasible power\n")
      next
    }
    if(print_info) cat("normal row\n")
  }
  
  text_equation <- paste(text_equation,collapse = "")
  return(text_equation)
}


#' This function only etracts the inside information of the parenthesis, so
#' I guessing that Macaulay don't uses parenthesis in its expressions.
#' 
#' for instance, 
#' vec <- "(hola) como ((doble) y otro)"
#' str_extract_all(vec, "\\([^()]+\\)")[[1]]
#' returns
#' "(hola)"  "(doble)"
#' so, the "y otro" is eliminated
#'
#' @param text_equation 
#'
#' @return
#' @export
#'
#' @examples
extracting_all_ideal_equations <- function(text_equation) {
  
  # First we get the information inside the parenthesis
  vec_ideals <- str_extract_all(text_equation, "\\([^()]+\\)")[[1]]
  # Now, we eliminate the parenthesis
  for(i in 1:length(vec_ideals)){
    vec_ideals[i] <- substr(vec_ideals[i],2,nchar(vec_ideals[i])-1)
  }
  # At this point we have a long string with all the equations, so we need
  # to separate it by its commas.
  # Other cleaning of the
  vec_ideals <- gsub("\\s+", "", str_trim(vec_ideals)) # elimination of spaces
  # vec_ideals <- sort(unlist(strsplit(vec_ideals, split=',', fixed=TRUE))) # Separating by commas
  # vec_ideals <- unique(vec_ideals)
  return(vec_ideals)
}

